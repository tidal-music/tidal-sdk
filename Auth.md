# Auth

The Auth module is responsible for handling authentication and authorization within an app. All logic related to login
and creating, updating and persisting access tokens is encapsulated in this module. The Auth module is also intended to
be used as a "single source of truth" for client id and user id in the app, guaranteeing full consistency between access
tokens and client id/user id.
Isolating this logic into one module allows us to clearly define ownership of authentication and authorization related
logic, and will also simplify the authorization process for the rest of the application.

The Auth module is designed to be easy to use, handling all the heavy lifting involved with acquiring and managing
access and refresh tokens. The user of the Auth module should not need to have any detailed knowledge about OAuth flows,
but should still be able to retrieve access tokens in a secure and performant manner.

Another important aspect of the Auth module is that it shall guarantee that users are never logged out unless one of the
following two scenarios occurs:

1. The user explicitly requests to be logged out (the `logout` function on the Auth module is called).
1. The session is explicitly revoked by TIDAL.

This module design is written based on
the [OAuth 2.1 draft](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-10). [OAuth 2.1](https://oauth.net/2.1/)
is compatible with OAuth 2.0 and is an in-progress effort to consolidate and simplify the most commonly used features of
OAuth 2.0.

# Terminology

* _[Authentication](https://en.wikipedia.org/wiki/Authentication)_ - The act of proving an assertion, such as the
  identity of a computer system user.
* _[Authorization](https://en.wikipedia.org/wiki/Authorization)_ - The function of specifying access rights/privileges
  to resources.
* _[Authorization code](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-10#name-authorization-code)_ - A
  temporary credential used to obtain an access token.
* _[Access token](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-10#name-access-token)_ - Credential used
  to access protected resources.
* _Login_ - The entire process leading up to the Auth module acquiring a valid user access token.
* _[OAuth](https://oauth.net/)_ - An open protocol to allow secure authorization in a simple and standard method from
  web, mobile and desktop applications.
* _[Refresh token](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-10#name-refresh-token)_ - Used to obtain
  a new access token when the current access token becomes invalid or expires, or to obtain additional access tokens
  with identical or narrower scope.

# API

## Auth

The `Auth` role exposes initialization and configuration.

### init

```java
/**
 * Initializes Auth.
 *
 * The Auth module is intended to be used as a singleton (only exist in a single instance in the app). There are several reasons for this, but mainly it has to do with efficiency and performance.
 *
 * The init function uses the user defined credentialsStorageKey parameter to either lookup existing credentials, or as key for storing any new credentials generated by the Auth module.
 * If persisted credentials are found, the init function shall validate these existing credentials against the parameters supplied to the init function and take the following actions:
 ** If the parameters clientId/scopes/clientSecret/clientUniqueKey supplied to init match the persisted ones, the persisted credentials are “loaded” by the Auth module, effectively causing the Auth module to resume the state it was in when its execution was last terminated.
 ** If any of the parameters clientId/scopes/clientSecret/clientUniqueKey supplied to init differs from the persisted ones, the Auth module will perform a so-called upgrade at a later stage. See "Upgrading credentials" section below for further information.
 *
 * @param credentialsStorageKey A user defined key used to look up any previously persisted credentials, and to use for persisting new credentials. Enables support for multiple credentials, i.e. supporting multiple users logged in to the same app.
 * @param clientId The client id
 * @param scopes Requested scopes (if any).
 * @param clientSecret Client secret (if any). Added to any calls made towards the token endpoint if set. Required in order to create client credentials access token.
 * @param clientUniqueKey Client unique key (if any).
 * @param tidalLoginServiceBaseUri Optional base URI to the TIDAL login service. Defaults to TIDAL production environment.
 * @param tidalAuthServiceBaseUri Optional base URI to the TIDAL auth service, providing the token endpoint. Defaults to TIDAL production environment.
 * @param certificatePinning Optional parameter that can be used to disable certificate pinning. Should really only be disabled during debugging.
 */
init(String credentialsStorageKey,
     String clientId,
     Set<String>? scopes=null,
     String? clientSecret=null,
     String? clientUniqueKey=null,
     URI? tidalLoginServiceBaseUri="https://login.tidal.com",
     URI? tidalAuthServiceBaseUri="https://auth.tidal.com/v1",
     Bool certificatePinning = True);
```

### initializeLogin

```java
/**
 * Initializes the standard login process (Auth code + PKCE) by updating internal state (code challenge, state variable etc) and generating a correct URL to the TIDAL login service.
 *
 * @param redirectUri URI that the TIDAL login service will redirect to after user authentication is complete.
 * @param loginConfig Optional configuration for the TIDAL login service.
 * @return A URI to the TIDAL login service that the app needs to present to the end user. Corresponds to AuthorizationRequest
 */
URI initializeLogin(URI redirectUri, LoginConfig? loginConfig);
```

### finalizeLogin

```java
/**
 * Finalizes the standard login process by retrieving an access token.
 * The Auth module must have been correctly configured before calling this function. In addition, a user login must have been performed using the "initializeLogin" URL.
 *
 * @param loginResponseQuery The full, untouched, query component of the redirect URI called by the TIDAL login service. Corresponds to AuthorizationResponse.
 * @throws AuthorizationError Raised if the loginResponseURI indicates that user authentication/authorization failed was not successful. Corresponds to AuthorizationResponse error.
 * @throws TokenResponseError Operation failed due to an unrecoverable error occurring when requesting the access token.
 */
Void finalizeLogin(String loginResponseQuery) throws AuthorizationError, TokenResponseError, Common.NetworkError, Common.RetryableError;
```

### initializeDeviceLogin

```java
/**
 * Initializes a device authorization login flow by generating DeviceAuthorizationResponse and updating internal state (device code etc).
 *
 * @return A DeviceAuthorizationResponse.
 */
DeviceAuthorizationResponse initializeDeviceLogin() throws Common.NetworkError, Common.RetryableError;
```

### finalizeDeviceLogin

```java
/**
 * Finalizes the device login flow. Blocks until either a valid access token is received, or an unrecoverable error occurs.
 *
 * @throws TokenResponseError Operation failed due to an unrecoverable error occurring when requesting the access token.
 */
Void finalizeDeviceLogin() throws TokenResponseError, Common.NetworkError, Common.RetryableError;
```

### setCredentials

```java
/**
 * Explicitly sets an access token and optional refresh token that have been acquired elsewhere. Used, for example, during migrations, testing or in apps that only get access tokens propagated to them (e.g. cast).
 * The explicitly set credentials will be persisted using the configured credentialsStorageKey supplied in the init function. If any existing credentials were stored for that key, they will be overwritten.
 *
 * A successful call to this function will result in a CredentialsUpdatedMessage being sent.
 *
 * NOTE: This function should be used with care, since it allows for setting the Auth module in an inconsistent state. Even though some validation is done by this function by checking the fields in the Credentials object match the values with which the module was initialized, there is still a possibility that the actual access token does not match configured values.
 *
 * @param credentials Credentials to set
 * @param refreshToken Refresh token to set
 * @throws IllegalArgumentError This function validates that the supplied Credentials matches the values supplied to the init function, i.e. clientId matches, credentials scopes are a subset of the scopes supplied in init and clientUniqueKey matches. If it doesn't match, IllegalArgumentError is raised.
 */
Void setCredentials(Credentials credentials, String? refreshToken) throws Common.IllegalArgumentError;
```

### logout

```java
/**
 * Performs a local logout, meaning that any locally stored user access token and/or refresh token will be purged.
 */
Void logout();
```

## CredentialsProvider

The `CredentialsProvider` role supplies functionality for retrieving credentials from the Auth module. It is intended to 
be used in all places in the app where credentials are needed.

### getCredentials

```java
/**
 * This function is intended to be called by the app each time it needs credentials.
 *
 * If needed to guarantee that the returned credentials are correct, valid and up-to-date, this function will trigger an update of the existing credentials before returning the Credentials object. If credential update fails, the Promise will raise an error, indicating what failed.
 * This function is thread safe
 *
 * @param apiErrorSubStatus An optional parameter that is used to indicate that a retry is being made in case a 401 was received from backend during a previous request.
 * @return A Credentials object promise.
 * @throws RetryableError Raised (via the Promise) if credentials needed updating, but updating failed. Try again at a later stage.
 * @throws IllegalConfigurationError Raised (via the Promise) if client credentials needed to be created, but the configuration of the client prohibits creating credentials.
 */
Promise<Credentials, Common.RetryableError, Common.IllegalConfigurationError> getCredentials(String? apiErrorSubStatus=null);
```

### isUserLoggedIn

```java
/**
 * Convenience function to quickly check if a user is logged in.
 *
 * @return True if a user is logged in, false otherwise.
 */
Bool isUserLoggedIn();
```

### bus

```java
/**
 * The default bus, used for all asynchronous communication by the Auth module.
 */
Bus<CredentialsUpdatedMessage> bus;
```

## Types

### LoginConfig

```java
/**
 * Configuration parameters for the TIDAL login service.
 */
class LoginConfig {

    // Language (ISO 639-1 e.g. en/de/it) is used to set the language for the TIDAL login service. If left blank the browser language will be used.
    String? language =null;

    // Optional email address to be pre-filled on the login screen
    String? email =null;

    // Key value map used to add custom parameters to be passed through to the TIDAL login service. If set to null, a default configuration of TIDAL login service will be applied.
    Map<String, String>? customParameters =null;
}
```

### DeviceAuthorizationResponse

```java
/**
 * Object representing a Device authorization response.
 */
class DeviceAuthorizationResponse {

    // The device verification code.
    String deviceCode;

    // The end-user verification code.
    String userCode;

    // The end-user verification URI on the authorization server.
    String verificationUri;

    // Same as above, but containing the code for form auto-fill.
    String? verificationUriComplete;

    // The lifetime in seconds of the "device_code" and "user_code".
    Int expiresIn;

    // The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.
    Int interval;
}
```

### Credentials

```java
/**
 * Holds credentials information.
 * If it holds an access token, this object can be seen as an exploded version of that access token.
 */
class Credentials {

    // Client id
    String clientId;

    // Scopes requested when acquiring access token
    Set<String> requestedScopes;

    // Client unique key
    String? clientUniqueKey;

    // Scopes granted for access token
    Set<String>? grantedScopes;

    // User id associated with access token
    String? userId;

    // Instant in time when credentials expires
    Instant? expires;

    // String representing access token
    String? token;
}
```

### CredentialsUpdatedMessage

```java
/**
 * Message fired whenever the credentials provided by the Auth module change. For example after a refresh, login, logout, upgrade etc etc. Every time new credentials are created.
 */
class CredentialsUpdatedMessage {

    // The new credentials
    Credentials credentials;
}
```

### AuthorizationError

```java
/**
 * Error indicating that the user did not correctly authenticate themselves at the TIDAL login service. Raised when the URI made to the redirect URI indicates that the authentication was not succesful.
 */
class AuthorizationError {
}
```

### TokenResponseError

```java
/**
 * Error used to indicate that an access token could not be retrieved.
 */
class TokenResponseError {
}
```

# Functionality and Requirements

## Credentials levels

The Auth module shall define a hierarchy (levels) of the different types of credentials it can generate, hold and
provide. This hierarchy also defines much of the behavior of the Auth module, in that the Auth module will implicitly
always strive to deliver the "best possible" credentials it can.

The levels are:

* _User credentials_ (Highest level / "best") - OAuth user access token retrieved using an authorization code grant, or
  refresh grant.
* _Client credentials_ (Middle level / "second best") - OAuth client access token retrieved using client credentials
  grant.
* _Basic credentials_ (Lowest level / "third best") - Just the client id passed to init.

## Configuration

The Auth module can be configured using the functions available in the `Auth` role. For any given point in time, the
configuration of the Auth module decides what level of credentials the Auth module will provide when `getCredentials` is
called. Configuration includes actions such as logging in/out users, setting client id and client secret or defining
which previously existing state the Auth module shall continue from.

### Initialization

The Auth module is intended to only be instantiated once for an app (singleton), and the initialization is done using
the `init` function.

The parameters passed to `init` defines the basic configuration for the Auth module. The `init` function shall not
perform any complex operations, check any validity of existing credentials, or make any API calls. Its sole purpose is
to update the state/configuration of the Auth module to correspond to the supplied parameters.

### Standard Login

The standard login process (`initializeLogin` / `finalizeLogin`) involves the user successfully authenticating
themselves using the TIDAL login service, and the Auth module successfully exchanging the resulting authorization code
for an access token (and potentially also a refresh token).

The `initializeLogin` function generates a correctly formatted URL to the TIDAL login service that the app shall use to
present the TIDAL login service to the end user. The Auth module relies fully on the TIDAL login service (
login.tidal.com) to handle everything related to user authentication.
The URL returned by the `initializeLogin` function shall be structured like this:

```
{tidalLoginServiceBaseURI}/authorize
?response_type=code
&redirect_uri=<REDIRECT_URI>
&client_id=<CLIENT_ID>
&scope=<SCOPES>
&code_challenge_method=S256
&code_challenge=<CODE_CHALLENGE>
&<LOGIN_CONFIG>
```

Where:

* `REDIRECT_URI` - The redirect uri, as passed to `initializeLogin`.
* `CLIENT_ID` - The client id that the Auth module has been initialized with.
* `SCOPES` - The scopes that the Auth module has been initialized with.
* `CODE_CHALLENGE` - The code challenge as calculated according to the section below.
* `LOGIN_CONFIG` - All configs in the `loginConfig` parameter passed to `initializeLogin`, each as its own query
  parameter.

As can be seen in the URI above, the Auth module shall generate a code challenge using the SHA256 method. Follow the
instructions [here](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-10#section-4.1.1) in order to correctly
generate the `code_verifier` and `code_challenge` for the S256 `code_challenge_method`. Note that the Auth module must
temporarily store the `code_verifier`, since it shall be used in the corresponding call to `finalizeLogin`.

Once the TIDAL login service returns (calls the redirect URI supplied to `initializeLogin`), the app shall
call `finalizeLogin` with the full, unmodified, query string of the URI that was called by the TIDAL login service.
The `finalizeLogin` function shall validate the response from the TIDAL login service, raising an `AuthorizationError`
if it contains an error message. If the response from the TIDAL login service was successful (contains an authorization
code), `finalizeLogin` shall make a call to the token endpoint, exchanging the authorization code for an access token (
and potentially also a refresh token) as
described [here](https://developer.tidal.com/documentation/authorization/authorization-overview).

If any 4xx error is returned from the token endpoint, the `finalizeLogin` function shall raise
a `Common.UnexpectedError` with the `errorCode` set to the error field from the backend error response.

If any 5xx error is returned from the token endpoint, the `finalizeLogin` function shall retry 5 times, with exponential
backoff (0.5s, 1s, 2s etc), before giving up and raising a `Common.RetryableError` with the `errorCode` set to the error
field from the backend error response.

If a successful response is returned from the token endpoint, the Auth module shall persist the received credentials
using the configured `credentialsStorageKey`, overwriting any existing credentials.

### Device login

The device login process (`initializeDeviceLogin` / `finalizeDeviceLogin`) is recommended to be used when logging in
users on devices with limited input capabilities, for example TVs. The login process involves redirecting the user to a
secondary device where the authentication/authorization takes
place. See API documentation for the device login flow for further information.

The `initializeDeviceLogin` function makes a device authorization request towards the auth backend, returning the
resulting `DeviceAuthorizationResponse`. The Auth module must temporarily hold the `DeviceAuthorizationResponse`
returned from the backend, since it will use parts of it in the subsequent polling triggered by a call to
the `finalizeDeviceLogin` function.

After presenting the information in the `DeviceAuthorizationResponse` object to the end user, the app must
call `finalizeDeviceLogin` in order to finalize the login. This function blocks (polls) until either an access/refresh
token has been received from backend, or until an unrecoverable error was received from the token endpoint, in which
case a `TokenResponseError` is raised.

If any 5xx error is returned from any of the endpoints called, the corresponding function shall retry 5 times, with
exponential backoff (0.5s, 1s, 2s etc), before giving up and raising a Common.RetryableError with the errorCode set to
the error field from the backend error response.

If a successful response is returned from the token endpoint, the Auth module shall persist the received credentials
using the configured `credentialsStorageKey`, overwriting any existing credentials.

### Setting credentials

The Auth module supports explicitly setting credentials (access token and optionally a refresh token) obtained elsewhere
via the `setCredentials` function.

The Auth module shall persist the supplied credentials using the configured `credentialsStorageKey`, overwriting any
existing credentials.

## Providing credentials

The Auth module shall provide credentials to the rest of the app via the `getCredentials` function in
the `CredentialsProvider` role.

On each call to `getCredentials`, the Auth module shall verify that it delivers the best possible valid credentials
according to its current configuration.

* The term “best possible” refers to the credentials levels, meaning that the Auth module shall verify that it delivers
  the highest level of credentials its configuration allows.
* The term “valid” means that the credentials returned shall be valid for use, for at least 60 more seconds.
    * Note, there are corner cases where the Auth module cannot guarantee the validity of provided credentials,
      primarily in cases where an access token has been revoked by the TIDAL backend. See API errors section below for
      further details.

If a credential update is needed in order to deliver the best possible valid credentials, the Promise returned
from `getCredentials` shall not resolve until the update has successfully been performed (or an error was raised),
guaranteeing that `getCredentials` always returns the best possible valid credentials. In the vast majority of the cases
when `getCredentials` is called, the Promise will be completed immediately since the Auth module will already hold the
best possible valid credentials it can deliver.

In practice, this means that `getCredentials` shall return the following:

* If a user is logged in - A `Credentials` object containing user credentials shall be returned.
* If no user is logged in, but a `clientSecret` has been provided to `init` - A `Credentials` object containing client
  credentials shall be returned.
* If neither a user is logged in nor a client secret provided to `init` - A `Credentials` object containing basic
  credentials shall be returned.
* If the Auth module fails to provide the best possible credentials given its configuration, a call to `getCredentials`
  shall raise an error.

The rationale behind this behavior is to make both implementation and usage of the Auth module as simple as possible.
The implementation can be made pretty straight-forward, avoiding background processes to handle e.g. credentials
updates. A user of the Auth module can also always assume it gets the best possible valid credentials the Auth module
can provide.

The different scenarios that may cause a call to `getCredentials` to lead to a credential update are outlined in the
sections below.

### Upgrading credentials

The credentials upgrade functionality allows the Auth module to seamlessly transition between different clients and 
client configurations, also without logging out users.

A credentials upgrade shall be performed by `getCredentials` whenever the `credentialsStorageKey` passed to `init`
points to a set of existing credentials, but any of the parameters `clientId`, `scopes`, `clientSecret` or
`clientUniqueKey` passed to `init` differ from the ones that was used to retrieve the existing credentials. This means
that on each call to `getCredentials`, `getCredentials` shall perform a credentials upgrade whenever both of the 
following is true:

1. The Auth module holds valid credentials stored at `credentialsStorageKey`.
1. Any of the parameters `clientId`, `scopes`, `clientSecret` or `clientUniqueKey` passed to `init` differ from the ones
  used to retrieve the existing credentials at `credentialsStorageKey`.

The Auth module shall support upgrades of both client credentials and user credentials.

* For client credentials, upgrades are performed simply by creating new client credentials using
  the [client credentials flow](https://developer.tidal.com/documentation/authorization/authorization-client-credentials).
* For user credentials, upgrades are performed using the TIDAL specific upgrade flow (available for internal clients).

Regardless of which flow is triggered to perform the upgrade, or what errors are occurring or are returned from the 
backend (network errors, 5xx errors, 4xx errors etc.), the upgrade shall be retried up to 5 times using exponential 
backoff (0.5s, 1s, 2s etc.) before causing `getCredentials` to raise a `Common.RetryableError`. This is a deliberate 
design that guarantees that a user can never get logged out during an upgrade just because something was misconfigured. 
The upgrade will be retried next time the user calls `getCredentials`.

If a successful response is returned from the token endpoint, the newly received credentials shall be persisted using
the configured `credentialsStorageKey`, overwriting any existing credentials, effectively finalizing the credentials
upgrade.

### Refreshing credentials

The Auth module shall support refreshing its credentials using
a [refresh token](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-10#name-refresh-token) in case it holds
one. Refreshing allows the Auth module to get a new user access token when the current one has expired, using the
refresh token in the [refresh flow](https://developer.tidal.com/documentation/authorization/authorization-overview).

As mentioned in the login section, the call to the token endpoint made in `finalizeLogin` may result in both an access
token and a refresh token being received. The Auth module shall keep any refresh token strictly internal, i.e. it shall
be impossible for a user of the Auth module to get hold of the refresh token.

The Auth module shall use the refresh token to perform a refresh flow whenever a call to `getCredentials` is made and
the user access token is no longer valid (expires within 60s, API error).

In case any of the errors (status/sub_status) listed below are returned from the token endpoint when performing the 
refresh flow, the Auth module shall consider it a logout event, causing the existing user credentials to be cleared and 
`getCredentials` to complete the returned Promise with a `Credentials` object with a lower level credentials (client 
credentials or basic credentials).
* `400` / `unauthorized_client`
* `400` / `invalid_grant`
* `400` / `invalid_request`
* `401` / `access_denied`
* `401` / `invalid_client`

In case a 5xx error is returned from the token endpoint when performing the refresh flow, the Auth module shall retry
the refresh up to 5 times using exponential backoff (0.5s, 1s, 2s etc) before throwing a `Common.RetryableError`. The
refresh will be retried next time the user calls `getCredentials`.

If a successful response is returned from the token endpoint, the Auth module shall persist the received credentials
using the configured `credentialsStorageKey`, overwriting any existing credentials.

### Client credentials

In case the Auth module has been initialized with a `clientSecret`, but no user is logged in, the best possible
credential the Auth module can generate are so-called client credentials.

Client credentials shall be generated using
the [client credentials flow](https://developer.tidal.com/documentation/authorization/authorization-client-credentials)
if both the following conditions are met:
A call to `getCredentials` is made and the Auth module does not hold a valid access token or refresh token.
The Auth module was initialized with a `clientSecret`.

In case any of the 4xx errors documented in the Token endpoint error appendix below is returned from the token endpoint
when performing the client credentials flow, a `Common.IllegalConfigurationError` shall be raised, using the value in
the `sub_status` field as error code.

In case a 5xx error is returned from the token endpoint when performing the refresh flow, the Auth module shall retry
the client credentials creation up to 5 times using exponential backoff (0.5s, 1s, 2s etc) before throwing
a `RetryableError`. The client credentials creation will be retried next time the user calls `getCredentials`.

If a successful response is returned from the token endpoint, the Auth module shall persist the received credentials
using the configured `credentialsStorageKey`, overwriting any existing credentials.

### API errors

In case the app gets a 401 Unauthorized response from the TIDAL API when using an access token acquired
via `getCredentials`, the app shall call `getCredentials` again, supplying the value of the `subStatus` field in the 401
response as the `apiErrorSubStatus` parameter to `getCredentials`. Hence, if the `apiErrorSubStatus` parameter is
provided in the call to `getCredentials`, it indicates a “retry” by the app.

If the value of the `apiErrorSubStatus` is any of the following: `["11003", "6001, "11001", "11002", "11101"]`,
the `getCredentials` function shall perform a refresh flow, and return the best possible credentials available after
that refresh flow has completed. Note that the refresh flow might trigger a logout.

If the value of the `apiErrorSubStatus` is any other than the above-mentioned, no special action shall be taken
by `getCredentials`, and it shall behave as if `apiErrorSubStatus` was not set. This behavior implies that the app
should monitor whether or not it gets new credentials when calling `getCredentials` with `apiErrorSubStatus` set, not to
end up in an infinite loop.

## Persisting credentials

The Auth module shall persist the credentials it holds, making sure that credentials are made available across restarts
of the app that is using the Auth module.

The Auth module shall persist credentials each time it has obtained new ones (credentials created, updated or deleted),
guaranteeing that an unexpected (or expected) exit of the app will result in the latest set of credentials being loaded
next time the Auth module gets initialized using the same `credentialsStorageKey`. If the implementation follows this
recommendation, the firing of the `CredentialsUpdatedMessage` can be implemented to fire each time there is an update to
the storage for the currently active `credentialsStorageKey`.

The Auth module shall store credentials in a key-value store or similar, using the `credentialsStorageKey` parameter
passed to init as key, and the corresponding `Credentials` object + refresh token as value. The example below
illustrates the proposed key and value for persisting credentials.

```java
class Credentials {
    Credentials credentials;
    String?refreshToken;
}

class CredentialsStorage {
    Value?

    get(String credentialsStorageKey);

    Void set(String key, Credentials value);
}
```

The state shall be persisted in a way that makes it as hard as possible for an external actor to retrieve the stored
information.

## Certificate pinning

Certificate pinning is a common security technique used to protect against Man-In-The-Middle-Attack. Clients store a set
of AWS SSL certificate Public Keys and consider them as the only valid ones when making a SSL handshake against the
oAuth servers (https://auth.tidal.com/v1). In other words, authentication will fail if a middle-man with a custom
certificate is listening to the connection. More information about certificate pinning by AWS can be
found [here](https://docs.aws.amazon.com/acm/latest/userguide/acm-bestpractices.html#best-practices-pinning).

Currently, the TIDAL Android and iOS app enforce certificate pinning upon authentication. On Android, it is done through
OkHttp’s [CertificatePinner](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/). On iOS, it is
done natively through [Identity Pinning](https://developer.apple.com/news/?id=g9ejcf8y). The implementation on both
platforms is straightforward and brings valuable security protection to clients integrating the Auth
SDK.

Implementations of the Auth module that implements certificate pinning shall ship with certificates included and
certificate pinning enabled by default. The Auth module has an optional flag for disabling certificate pinning in its
init function - something that should really only be done for debug purposes.